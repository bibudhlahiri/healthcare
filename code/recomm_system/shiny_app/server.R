file_path <- "/Users/blahiri/healthcare/data/tcga/Raw_Data/v3"
load(paste(file_path, "/vital_logr.rda", sep = ""))
drug_vars <- c("Avastin", "BCNU", "CCNU", "CPT.11", "Dexamethasone", "Gliadel.Wafer",  
                           "Other_drug", "Tarceva", "Temozolomide", "VP.16")
radiation_vars <- c("EXTERNAL.BEAM", "Other_radiation")

inputs_for_demog_ch <<- list()

#The input is a bit vector that specifies a chromosome, which essentially 
#tells which of the treatment options will be used. The output is the negative of the 
#linear combination generated by logistic regression. The negative is taken because 
#rbga.bin only minimizes the objective function.

evalFunc <- function(bit_string)
{
  
  file_path <- "/Users/blahiri/healthcare/data/tcga/Raw_Data/v3"
  load(paste(file_path, "/vital_logr.rda", sep = ""))

  obj_func <- as.numeric(vital.logr$coefficients[1:16]) %*% as.numeric(inputs_for_demog_ch)

  obj_func <- obj_func + as.numeric(vital.logr$coefficients[17:28]) %*% bit_string
  n_bits <- length(bit_string)
  if ((sum(bit_string) > 3) || (sum(bit_string[(n_bits-1): n_bits]) == 2))
  {
    return(0)
  }
  else
  {
    return(-obj_func)
  }
}

genetic_algorithm_for_optimal <- function(input_data)
{
  library(genalg)
  treatment_options <- sort(append(drug_vars, radiation_vars))
  n_options <- length(treatment_options)

  inputs_for_demog_ch[["intercept_coeff"]] <<- 1
  inputs_for_demog_ch[["age_at_initial_pathologic_diagnosis"]] <<- input_data[["age_at_initial_pathologic_diagnosis"]]
  inputs_for_demog_ch[["ethnicityHISPANIC OR LATINO"]] <<- as.numeric(input_data[["ethnicity"]] == 'HISPANIC OR LATINO')
  inputs_for_demog_ch[["genderMALE"]] <<- as.numeric(input_data[["gender"]] == 'MALE')
  inputs_for_demog_ch[["histological_typeTreated primary GBM"]] <<- as.numeric(input_data[["histological_type"]] == 'Treated primary GBM')
  inputs_for_demog_ch[["histological_typeGlioblastoma Multiforme (GBM)"]] <<- as.numeric(input_data[["histological_type"]] == 'Glioblastoma Multiforme (GBM)')
  inputs_for_demog_ch[["history_of_neoadjuvant_treatmentNo"]] <<- as.numeric(input_data[["history_of_neoadjuvant_treatment"]] == 'No')
  inputs_for_demog_ch[["initial_pathologic_diagnosis_methodExcisional Biopsy"]] <<- as.numeric(input_data[["initial_pathologic_diagnosis_method"]] == 'Excisional Biopsy')
  inputs_for_demog_ch[["initial_pathologic_diagnosis_methodIncisional Biopsy"]] <<- as.numeric(input_data[["initial_pathologic_diagnosis_method"]] == 'Incisional Biopsy')
  inputs_for_demog_ch[["initial_pathologic_diagnosis_methodOther method, specify:"]] <<- as.numeric(input_data[["initial_pathologic_diagnosis_method"]] == 'Other method, specify:')
  inputs_for_demog_ch[["initial_pathologic_diagnosis_methodFine needle aspiration biopsy"]] <<- as.numeric(input_data[["initial_pathologic_diagnosis_method"]] == 'Fine needle aspiration biopsy')
  inputs_for_demog_ch[["karnofsky_performance_score"]] <<- input_data[["karnofsky_performance_score"]]
  inputs_for_demog_ch[["person_neoplasm_cancer_statusTUMOR FREE"]] <<- as.numeric(input_data[["person_neoplasm_cancer_status"]] == 'TUMOR FREE')
  inputs_for_demog_ch[["prior_gliomaYES"]] <<- as.numeric(input_data[["prior_glioma"]] == 'YES')
  inputs_for_demog_ch[["raceBLACK OR AFRICAN AMERICAN"]] <<- as.numeric(input_data[["race"]] == 'BLACK OR AFRICAN AMERICAN')
  inputs_for_demog_ch[["raceASIAN"]] <<- as.numeric(input_data[["race"]] == 'ASIAN')
  
  
  GAmodel <- rbga.bin(size = n_options, popSize = 200, iters = 7, 
                      mutationChance = 1/(n_options + 1), elitism = T, evalFunc = evalFunc, verbose = TRUE)
  df <- process_output_of_genetic(GAmodel, treatment_options)
}

#Rank the chromosomes of the final population by evaluation. Since the GA 
#minimizes the objective function, the lower the evaluation, the higher they should 
#be ranked. Survival probability = sigmoid(-evaluation)

process_output_of_genetic <- function(GAmodel, treatment_options)
{
  df <- as.data.frame(GAmodel$population)
  df$evaluation <- GAmodel$evaluations
  df$surv_prob <- invlogit(-df$evaluation)
  df <- df[order(-df[, "surv_prob"]),]
  df <- df[!duplicated(df), ]
  df$combination <- apply(df, 1, function(row) convert_bit_string_to_text(row[paste("V", 1:12, sep = "")], treatment_options)) 
  df <- df[,!(names(df) %in% c("evaluation", paste("V", 1:12, sep = "")))]
  row.names(df) <- NULL
  df <- df[c(2,1)]
  colnames(df) <- c("Combination", "1-year survival probability")
  df
}

#Need to get the levels of the factor variables
dense_matrix <- read.csv(paste(file_path, "/", "clinical_all_combined_gbm.csv", sep = ""))

evaluate_node <- function(bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, response_var, 
                          input_data)
{
  columns <- c(demog_ch_vars, treatment_options)
  test_row <- data.frame(matrix(ncol = length(columns)))
  colnames(test_row) <- columns
  
  #Values for demo and case history variables are obtained from input form

  for (demog_ch_var in demog_ch_vars)
  {
    test_row[1, demog_ch_var] <- input_data[[demog_ch_var]]
  }

  for (j in 1:n_options)
   {
     if (bit_string[j])
     {
       test_row[1, treatment_options[j]] = 'TRUE'
     }
     else
     {
       test_row[1, treatment_options[j]] = 'FALSE'
     }
   }
  for (column in columns)
  {
    if (column != response_var & is.factor(dense_matrix[, column]))
    { 
      test_row[, column] <- factor(test_row[, column], levels = unique(dense_matrix[, column]))
    }
  }
  cond_prob = predict(vital.logr, test_row, type = "response")
}

convert_bit_string_to_text <- function(bit_string, treatment_options)
{
  paste(treatment_options[which(bit_string == 1)], collapse = ", ")
}


custom_hill_climbing_for_optimal <- function(input_data)
{
  treatment_options <- sort(append(drug_vars, radiation_vars))
  n_options <- length(treatment_options)
  bit_string <- rep(FALSE, length(treatment_options))

  #pick an option at random, to start with. A node is an assignment of values to the evidence variables.
  current <- sample(treatment_options, 1)
  bit_string[which(treatment_options == current)] <- TRUE
  
  #Fix some values for the demographic and case history variables, for now
  demog_ch_vars <- c("age_at_initial_pathologic_diagnosis", "ethnicity", "gender", "race", "histological_type", "history_of_neoadjuvant_treatment", 
                     "initial_pathologic_diagnosis_method", "karnofsky_performance_score", "person_neoplasm_cancer_status", "prior_glioma")
  current_val <- evaluate_node(bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, "lived_past_one_year", 
                               input_data)
 
  while (TRUE)
  {
    cat(paste("current evidence = ", convert_bit_string_to_text(bit_string, treatment_options), ", current_val = ", current_val, "\n\n", sep = ""), file = stderr())
    #Generate all neighbors of current by a successor function. The neighbors are generated by toggling one 
    #bit in bit_string at a time
    max_score_from_neighbor <- 0
    for (i in 1:n_options)
    {
        #Generate a neighbor by toggling the i-th bit of bit_string
        neighbor_bit_string <- bit_string
        neighbor_bit_string[i] <- !bit_string[i]
        #All 0s can be generated as a neighbor but it is not a valid evidence, so skip it
        if (sum(neighbor_bit_string) > 0)
        {
          #Generate the evidence corresponding to the neighbor
          this_neighbor_val <- evaluate_node(neighbor_bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, "lived_past_one_year",
                                             input_data)
          if (this_neighbor_val > max_score_from_neighbor)
          {
            max_score_from_neighbor <- this_neighbor_val
            highest_scoring_neighbor <- neighbor_bit_string
          }
        }
    }
    #Now, all neighbors are processed for current node
    if (max_score_from_neighbor <= current_val)
    { 
      cat(paste("Reached maxima at ", current_val, "\n\n", sep = ""), file = stderr())
      return(convert_bit_string_to_text(bit_string, treatment_options))
    }
    #Setting current to highest scoring neighbor for the next iteration. bit_string represents the current node
    bit_string <- highest_scoring_neighbor
    current_val <- max_score_from_neighbor

    #Temporary fix for different results: take combination of 4 options at most

    if ((sum(highest_scoring_neighbor) >= 4) || (max_score_from_neighbor == 1))
    {
      return(convert_bit_string_to_text(highest_scoring_neighbor, treatment_options))
    }
  }
}



# Define server logic required to do the hill climbing for a given patient
shinyServer(function(input, output) {

  datasetInput <- reactive({

    age_at_initial_pathologic_diagnosis <- input$age_at_initial_pathologic_diagnosis
    ethnicity <- input$ethnicity
    gender <- input$gender
    race <- input$race
    histological_type <- input$histological_type
    history_of_neoadjuvant_treatment <- input$history_of_neoadjuvant_treatment
    initial_pathologic_diagnosis_method <- input$initial_pathologic_diagnosis_method
    karnofsky_performance_score <- input$karnofsky_performance_score
    person_neoplasm_cancer_status <- input$person_neoplasm_cancer_status
    prior_glioma <- input$prior_glioma

    list("age_at_initial_pathologic_diagnosis" = age_at_initial_pathologic_diagnosis, 
         "ethnicity" = ethnicity, "gender" = gender, "race" = race, "histological_type" = histological_type,
         "history_of_neoadjuvant_treatment" = history_of_neoadjuvant_treatment, "initial_pathologic_diagnosis_method" = initial_pathologic_diagnosis_method,
         "karnofsky_performance_score" = karnofsky_performance_score, "person_neoplasm_cancer_status" = person_neoplasm_cancer_status,
         "prior_glioma" = prior_glioma)
  })

  output$ranked_results <- renderTable({
    
    input_data <- datasetInput()
    #custom_hill_climbing_for_optimal(input_data)
    genetic_algorithm_for_optimal(input_data)
  })
})










