file_path <- "/Users/blahiri/healthcare/data/tcga/Raw_Data/v3"
load(paste(file_path, "/vital_logr.rda", sep = ""))
drug_vars <- c("Avastin", "BCNU", "CCNU", "CPT.11", "Dexamethasone", "Gliadel.Wafer",  
                           "Other_drug", "Tarceva", "Temozolomide", "VP.16")
radiation_vars <- c("EXTERNAL.BEAM", "Other_radiation")

#Need to get the levels of the factor variables
dense_matrix <- read.csv(paste(file_path, "/", "clinical_all_combined_gbm.csv", sep = ""))

evaluate_node <- function(bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, response_var, 
                          input_data)
{
  columns <- c(demog_ch_vars, treatment_options)
  test_row <- data.frame(matrix(ncol = length(columns)))
  colnames(test_row) <- columns
  
  #Values for demo and case history variables are obtained from input form

  for (demog_ch_var in demog_ch_vars)
  {
    test_row[1, demog_ch_var] <- input_data[[demog_ch_var]]
  }

  for (j in 1:n_options)
   {
     if (bit_string[j])
     {
       test_row[1, treatment_options[j]] = 'TRUE'
     }
     else
     {
       test_row[1, treatment_options[j]] = 'FALSE'
     }
   }
  for (column in columns)
  {
    if (column != response_var & is.factor(dense_matrix[, column]))
    { 
      test_row[, column] <- factor(test_row[, column], levels = unique(dense_matrix[, column]))
    }
  }
  cond_prob = predict(vital.logr, test_row, type = "response")
}

convert_bit_string_to_text <- function(bit_string, treatment_options)
{
  paste("Optimal combination is", paste(treatment_options[which(bit_string)], collapse = ", "), sep = " ")
}

custom_hill_climbing_for_optimal <- function(input_data)
{
  treatment_options <- sort(append(drug_vars, radiation_vars))
  n_options <- length(treatment_options)
  bit_string <- rep(FALSE, length(treatment_options))

  #pick an option at random, to start with. A node is an assignment of values to the evidence variables.
  current <- sample(treatment_options, 1)
  bit_string[which(treatment_options == current)] <- TRUE
  
  #Fix some values for the demographic and case history variables, for now
  demog_ch_vars <- c("age_at_initial_pathologic_diagnosis", "ethnicity", "gender", "race", "histological_type", "history_of_neoadjuvant_treatment", 
                     "initial_pathologic_diagnosis_method", "karnofsky_performance_score", "person_neoplasm_cancer_status", "prior_glioma")
  current_val <- evaluate_node(bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, "lived_past_one_year", 
                               input_data)
 
  while (TRUE)
  {
    #Generate all neighbors of current by a successor function. The neighbors are generated by toggling one 
    #bit in bit_string at a time
    max_score_from_neighbor <- 0
    for (i in 1:n_options)
    {
        #Generate a neighbor by toggling the i-th bit of bit_string
        neighbor_bit_string <- bit_string
        neighbor_bit_string[i] <- !bit_string[i]
        #All 0s can be generated as a neighbor but it is not a valid evidence, so skip it
        if (sum(neighbor_bit_string) > 0)
        {
          #Generate the evidence corresponding to the neighbor
          this_neighbor_val <- evaluate_node(neighbor_bit_string, treatment_options, n_options, demog_ch_vars, vital.logr, "lived_past_one_year",
                                             input_data)
          if (this_neighbor_val > max_score_from_neighbor)
          {
            max_score_from_neighbor <- this_neighbor_val
            highest_scoring_neighbor <- neighbor_bit_string
          }
        }
    }
    #Now, all neighbors are processed for current node
    if (max_score_from_neighbor <= current_val)
    { 
      return(convert_bit_string_to_text(bit_string, treatment_options))
    }
    #Setting current to highest scoring neighbor for the next iteration. bit_string represents the current node
    bit_string <- highest_scoring_neighbor
    current_val <- max_score_from_neighbor
    if (max_score_from_neighbor == 1)
    {
      return(convert_bit_string_to_text(highest_scoring_neighbor, treatment_options))
    }
  }
}



# Define server logic required to do the hill climbing for a given patient
shinyServer(function(input, output) {

  datasetInput <- reactive({

    age_at_initial_pathologic_diagnosis <- input$age_at_initial_pathologic_diagnosis
    ethnicity <- input$ethnicity
    gender <- input$gender
    race <- input$race
    histological_type <- input$histological_type
    history_of_neoadjuvant_treatment <- input$history_of_neoadjuvant_treatment
    initial_pathologic_diagnosis_method <- input$initial_pathologic_diagnosis_method
    karnofsky_performance_score <- input$karnofsky_performance_score
    person_neoplasm_cancer_status <- input$person_neoplasm_cancer_status
    prior_glioma <- input$prior_glioma

    list("age_at_initial_pathologic_diagnosis" = age_at_initial_pathologic_diagnosis, 
         "ethnicity" = ethnicity, "gender" = gender, "race" = race, "histological_type" = histological_type,
         "history_of_neoadjuvant_treatment" = history_of_neoadjuvant_treatment, "initial_pathologic_diagnosis_method" = initial_pathologic_diagnosis_method,
         "karnofsky_performance_score" = karnofsky_performance_score, "person_neoplasm_cancer_status" = person_neoplasm_cancer_status,
         "prior_glioma" = prior_glioma)
  })

  output$best_combo <- renderPrint({
    
    input_data <- datasetInput()
    custom_hill_climbing_for_optimal(input_data)
  })
})










